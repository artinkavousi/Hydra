import {
  j
} from "./chunk-7JM2RORH.js";
import {
  Boolean,
  InnerLabel,
  Label,
  Number$1,
  Overlay,
  Portal,
  Row,
  Select,
  String$1,
  Vector,
  createPlugin,
  debounce,
  formatVector,
  keyframes,
  normalizeVector,
  sanitizeVector,
  styled,
  useDrag,
  useInputContext,
  useInputSetters
} from "./chunk-Y4Z53VX4.js";
import "./chunk-7AEY6Z2M.js";
import "./chunk-WUD7RX7Q.js";
import {
  require_react
} from "./chunk-OU5AQDZK.js";
import {
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/leva/plugin/dist/leva-plugin.esm.js
var import_react = __toESM(require_react());
function mergeRefs(refs) {
  return (value) => {
    refs.forEach((ref) => {
      if (typeof ref === "function") ref(value);
      else if (ref != null) {
        ref.current = value;
      }
    });
  };
}
var Components = {
  Row,
  Label,
  Portal,
  Overlay,
  String: String$1,
  Number: Number$1,
  Boolean,
  Select,
  Vector,
  InnerLabel
};

// node_modules/@leva-ui/plugin-bezier/dist/leva-ui-plugin-bezier.esm.js
var import_react4 = __toESM(require_react());
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var useRange = () => {
  return (0, import_react4.useCallback)((v, size) => size * v, []);
};
var useInvertedRange = () => {
  return (0, import_react4.useCallback)((v, size) => v / size, []);
};
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 1e-3;
var SUBDIVISION_PRECISION = 1e-7;
var SUBDIVISION_MAX_ITERATIONS = 10;
var kSplineTableSize = 11;
var kSampleStepSize = 1 / (kSplineTableSize - 1);
var A = (aA1, aA2) => 1 - 3 * aA2 + 3 * aA1;
var B = (aA1, aA2) => 3 * aA2 - 6 * aA1;
var C = (aA1) => 3 * aA1;
var calcBezier = (aT, aA1, aA2) => {
  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
};
var getSlope = (aT, aA1, aA2) => {
  return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);
};
var binarySubdivide = (aX, aA, aB, mX1, mX2) => {
  let currentX, currentT, i = 0;
  do {
    currentT = aA + (aB - aA) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
  return currentT;
};
var newtonRaphsonIterate = (aX, aGuessT, mX1, mX2) => {
  for (let i = 0; i < NEWTON_ITERATIONS; ++i) {
    const currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0) {
      return aGuessT;
    }
    const currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
};
var LinearEasing = (x) => {
  return x;
};
var bezier$1 = (mX1, mY1, mX2, mY2) => {
  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
    throw new Error("bezier x values must be in [0, 1] range");
  }
  if (mX1 === mY1 && mX2 === mY2) {
    return LinearEasing;
  }
  const sampleValues = new Float32Array(kSplineTableSize);
  for (let i = 0; i < kSplineTableSize; ++i) {
    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
  }
  const getTForX = (aX) => {
    let intervalStart = 0;
    let currentSample = 1;
    let lastSample = kSplineTableSize - 1;
    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;
    const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    const guessForT = intervalStart + dist * kSampleStepSize;
    const initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  };
  return (x) => {
    if (x === 0 || x === 1) {
      return x;
    }
    return calcBezier(getTForX(x), mY1, mY2);
  };
};
var Svg = styled("svg", {
  width: "100%",
  height: "$controlWidth",
  marginTop: "$rowGap",
  overflow: "visible",
  zIndex: 100,
  "> path": {
    stroke: "$highlight3",
    strokeWidth: 2
  },
  g: {
    color: "$accent1",
    "&:hover": {
      color: "$accent3"
    },
    "&:active": {
      color: "$vivid1"
    }
  },
  circle: {
    fill: "currentColor",
    strokeWidth: 10,
    stroke: "transparent",
    cursor: "pointer"
  },
  "> line": {
    stroke: "$highlight1",
    strokeWidth: 2
  },
  "> g > line": {
    stroke: "currentColor"
  },
  variants: {
    withPreview: {
      true: {
        marginBottom: 0
      },
      false: {
        marginBottom: "$rowGap"
      }
    }
  }
});
var fadeIn = (o) => keyframes({
  "0%": {
    opacity: 0
  },
  "10%": {
    opacity: 0.8
  },
  "100%": {
    opacity: o
  }
});
var move = keyframes({
  "0%": {
    transform: "translateX(5%)"
  },
  "100%": {
    transform: "translateX(95%)"
  }
});
var PreviewSvg = styled("svg", {
  width: "100%",
  overflow: "visible",
  height: 6,
  "> circle": {
    fill: "$vivid1",
    cy: "50%",
    animation: `${fadeIn(0.3)} 1000ms both`,
    "&:first-of-type": {
      animationName: fadeIn(0.7)
    },
    "&:last-of-type": {
      animationName: move
    }
  }
});
var SyledInnerLabel = styled("div", {
  userSelect: "none",
  $flexCenter: "",
  height: 14,
  width: 14,
  borderRadius: 7,
  marginRight: "$sm",
  cursor: "pointer",
  fontSize: "0.8em",
  variants: {
    graph: {
      true: {
        backgroundColor: "$elevation1"
      }
    }
  }
});
var Container = styled("div", {
  display: "grid",
  gridTemplateColumns: "auto 1fr",
  alignItems: "center"
});
var HANDLE_RADIUS = 4;
function Line({
  sx,
  sy,
  cx,
  cy
}) {
  const a = Math.atan2(cy - sy, cx - sx);
  const cxs = cx - HANDLE_RADIUS * Math.cos(a);
  const cys = cy - HANDLE_RADIUS * Math.sin(a);
  return import_react4.default.createElement("line", {
    x1: cxs,
    y1: cys,
    x2: sx,
    y2: sy
  });
}
function BezierSvg({
  displayValue,
  onUpdate,
  withPreview
}) {
  const r = useRange();
  const ir = useInvertedRange();
  const [ref, {
    width,
    height
  }] = j();
  const svgRef = (0, import_react4.useRef)(null);
  const handleLeft = (0, import_react4.useRef)(null);
  const handleRight = (0, import_react4.useRef)(null);
  const bounds = (0, import_react4.useRef)();
  const bind = useDrag(({
    xy: [x, y],
    event,
    first,
    memo
  }) => {
    if (first) {
      bounds.current = svgRef.current.getBoundingClientRect();
      memo = [handleLeft.current, handleRight.current].indexOf(event.target);
      if (memo < 0) memo = x - bounds.current.left < width / 2 ? 0 : 1;
      memo *= 2;
    }
    const relX = x - bounds.current.left;
    const relY = y - bounds.current.top;
    onUpdate((v) => {
      const newV = [...v];
      newV[memo] = ir(relX, width);
      newV[memo + 1] = 1 - ir(relY, height);
      return newV;
    });
    return memo;
  });
  const {
    x1,
    y1,
    x2,
    y2
  } = displayValue;
  const {
    sx,
    sy,
    ex,
    ey,
    cx1,
    cy1,
    cx2,
    cy2
  } = (0, import_react4.useMemo)(() => ({
    sx: r(0, width),
    sy: r(1, height),
    ex: r(1, width),
    ey: r(0, height),
    cx1: r(x1, width),
    cy1: r(1 - y1, height),
    cx2: r(x2, width),
    cy2: r(1 - y2, height)
  }), [r, x1, y1, x2, y2, width, height]);
  return import_react4.default.createElement(Svg, _extends({
    ref: mergeRefs([svgRef, ref])
  }, bind(), {
    withPreview
  }), import_react4.default.createElement("line", {
    x1: sx,
    y1: sy,
    x2: ex,
    y2: ey
  }), import_react4.default.createElement("path", {
    fill: "none",
    d: `M${sx},${sy} C${cx1},${cy1} ${cx2},${cy2} ${ex},${ey}`,
    strokeLinecap: "round"
  }), import_react4.default.createElement("g", null, import_react4.default.createElement(Line, {
    sx,
    sy,
    cx: cx1,
    cy: cy1
  }), import_react4.default.createElement("circle", {
    ref: handleLeft,
    cx: cx1,
    cy: cy1,
    r: HANDLE_RADIUS
  })), import_react4.default.createElement("g", null, import_react4.default.createElement(Line, {
    sx: ex,
    sy: ey,
    cx: cx2,
    cy: cy2
  }), import_react4.default.createElement("circle", {
    ref: handleRight,
    cx: cx2,
    cy: cy2,
    r: HANDLE_RADIUS
  })));
}
var DebouncedBezierPreview = import_react4.default.memo(({
  value
}) => {
  const [, forceUpdate] = (0, import_react4.useReducer)((x) => x + 1, 0);
  const plotPoints = Array(21).fill(0).map((_, i) => 5 + value.evaluate(i / 20) * 90);
  return import_react4.default.createElement(PreviewSvg, {
    onClick: forceUpdate
  }, plotPoints.map((p, i) => import_react4.default.createElement("circle", {
    key: i + Date.now(),
    r: 3,
    cx: `${p}%`,
    style: {
      animationDelay: `${i * 50}ms`
    }
  })), import_react4.default.createElement("circle", {
    key: Date.now() - 1,
    r: 3,
    style: {
      animationTimingFunction: `cubic-bezier(${value.join(",")})`,
      animationDuration: `${plotPoints.length * 50}ms`
    }
  }));
});
function BezierPreview({
  value
}) {
  const [debouncedValue, set] = (0, import_react4.useState)(value);
  const debounceValue = (0, import_react4.useMemo)(() => debounce((v) => set(v), 250), []);
  (0, import_react4.useEffect)(() => void debounceValue(value), [value, debounceValue]);
  return import_react4.default.createElement(DebouncedBezierPreview, {
    value: debouncedValue
  });
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
var _excluded = ["handles"];
var abscissasSettings = {
  min: 0,
  max: 1,
  step: 0.01
};
var ordinatesSettings = {
  step: 0.01
};
var defaultSettings = {
  graph: true,
  preview: true
};
var BuiltIn = {
  ease: [0.25, 0.1, 0.25, 1],
  linear: [0, 0, 1, 1],
  "ease-in": [0.42, 0, 1, 1],
  "ease-out": [0, 0, 0.58, 1],
  "ease-in-out": [0.42, 0, 0.58, 1],
  "in-out-sine": [0.45, 0.05, 0.55, 0.95],
  "in-out-quadratic": [0.46, 0.03, 0.52, 0.96],
  "in-out-cubic": [0.65, 0.05, 0.36, 1],
  "fast-out-slow-in": [0.4, 0, 0.2, 1],
  "in-out-back": [0.68, -0.55, 0.27, 1.55]
};
var normalize = (input = [0.25, 0.1, 0.25, 1]) => {
  let _ref = typeof input === "object" && "handles" in input ? input : {
    handles: input
  }, {
    handles
  } = _ref, _settings = _objectWithoutProperties(_ref, _excluded);
  handles = typeof handles === "string" ? BuiltIn[handles] : handles;
  const mergedSettings = {
    x1: abscissasSettings,
    y1: ordinatesSettings,
    x2: abscissasSettings,
    y2: ordinatesSettings
  };
  const {
    value: _value,
    settings
  } = normalizeVector(handles, mergedSettings, ["x1", "y1", "x2", "y2"]);
  const value = _value;
  value.evaluate = bezier$1(..._value);
  value.cssEasing = `cubic-bezier(${_value.join(",")})`;
  return {
    value,
    settings: _objectSpread2(_objectSpread2(_objectSpread2({}, settings), defaultSettings), _settings)
  };
};
var sanitize = (value, settings, prevValue) => {
  const _value = sanitizeVector(value, settings, prevValue);
  const newValue = _value;
  newValue.evaluate = bezier$1(..._value);
  newValue.cssEasing = `cubic-bezier(${_value.join(",")})`;
  return newValue;
};
var {
  Label: Label2,
  Row: Row2,
  Vector: Vector2,
  Select: Select2
} = Components;
var optionKeys = ["custom", ...Object.keys(BuiltIn)];
var optionValues = [false, ...Object.values(BuiltIn).map((c) => c.toString())];
var selectSettings = {
  keys: optionKeys,
  values: optionValues
};
function SelectBezier({
  value,
  onUpdate
}) {
  const selectValue = (0, import_react4.useMemo)(() => optionValues.find((v) => v === value.toString()) || false, [value]);
  const args = {
    type: "SELECT",
    value: selectValue,
    settings: selectSettings
  };
  const setValue = (newValue) => newValue && onUpdate(newValue.split(","));
  const select = useInputSetters(_objectSpread2(_objectSpread2({}, args), {}, {
    setValue
  }));
  return import_react4.default.createElement(Select2, {
    value: selectValue,
    displayValue: select.displayValue,
    onUpdate: select.onUpdate,
    settings: selectSettings
  });
}
function Bezier() {
  const {
    label,
    value,
    displayValue,
    settings,
    onUpdate,
    setSettings
  } = useInputContext();
  const {
    graph,
    preview
  } = settings;
  return import_react4.default.createElement(import_react4.default.Fragment, null, import_react4.default.createElement(Row2, {
    input: true
  }, import_react4.default.createElement(Label2, null, label), import_react4.default.createElement(Container, null, import_react4.default.createElement(SyledInnerLabel, {
    graph,
    onClick: () => setSettings({
      graph: !graph
    })
  }, "𝑓"), import_react4.default.createElement(SelectBezier, {
    value,
    onUpdate
  }))), graph && import_react4.default.createElement(BezierSvg, {
    displayValue,
    onUpdate,
    withPreview: preview
  }), preview && import_react4.default.createElement(Row2, null, import_react4.default.createElement(BezierPreview, {
    value
  })), graph && import_react4.default.createElement(Row2, null, import_react4.default.createElement(Vector2, {
    value: displayValue,
    settings,
    onUpdate,
    innerLabelTrim: 2
  })));
}
var bezier = createPlugin({
  normalize,
  sanitize,
  format: (value, settings) => formatVector(value, settings),
  component: Bezier
});
export {
  bezier
};
//# sourceMappingURL=@leva-ui_plugin-bezier.js.map
